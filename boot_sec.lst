     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; Simple Bootloader for x86 systems
     3                                  ; - intial boot set up
     4                                  ; - switch into 32 bit protected mode
     5                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6                                  
     7                                  [org 0x7c00]
     8                                  
     9                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    10                                  ; Start up in 16 bit real mode
    11                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                                  
    13 00000000 BD0090                  	mov bp, 0x9000			; Set up stack pointer
    14 00000003 89EC                    	mov sp, bp
    15                                  
    16 00000005 BE[DF00]                	mov si, MSG_REAL_MODE		; Print REAl MODE message
    17 00000008 E80500                  	call printString
    18                                  
    19 0000000B E8A200                  	call switch_to_pm		; Initiate the switch to Protected mode
    20                                  
    21 0000000E EBFE                    	jmp $				; Infinite loop - Should never get here
    22                                  
    23                                  %include "print16.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; Prints null terminated string
     3                              <1> ; Put first letter into SI
     4                              <1> ; Set BX to number of bytes to use
     5                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6                              <1> printString:
     7 00000010 AC                  <1> 	lodsb				; Load the byte at address in SI to AL and Inc SI
     8 00000011 3C00                <1> 	cmp al,0			; check for end of line
     9 00000013 7405                <1> 	je printStringEnd
    10 00000015 E80300              <1> 	call printChar
    11 00000018 EBF6                <1> 	jmp printString
    12                              <1> printStringEnd:
    13 0000001A C3                  <1> 	ret
    14                              <1> 
    15                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16                              <1> ; Prints a single character to the BIOS 
    17                              <1> ; Teletype function
    18                              <1> ; Put char in AL
    19                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    20                              <1> printChar:
    21                              <1> 	; Call BIOS Routing to print
    22 0000001B 50                  <1> 	push ax
    23 0000001C 53                  <1> 	push bx
    24 0000001D B40E                <1> 	mov ah, 0x0e		; BIOS Teletype function
    25 0000001F B700                <1> 	mov bh,0		; Page 0
    26 00000021 B347                <1> 	mov bl, 0x47		; Text Attribute (light grey on black)
    27 00000023 CD10                <1> 	int 0x10		; call BIOS intterupt 0x10
    28 00000025 5B                  <1> 	pop bx
    29 00000026 58                  <1> 	pop ax
    30 00000027 C3                  <1> 	ret
    31                              <1> 
    32                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    33                              <1> ; Prints a byte or word in hex format
    34                              <1> ; Assumes value is in DX and can be 32 bit value
    35                              <1> ; Set BX to number of bytes to use
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> printHex:
    38 00000028 6651                <1> 		push ecx				; save cl
    39 0000002A B004                <1> 		mov al,4			; load number of bytes for full 32 bit number
    40 0000002C 28C8                <1> 		sub al,cl			; get number of byte to shift out for alignment	
    41 0000002E B108                <1> 		mov cl,8			; set bit multiplier
    42 00000030 F6E1                <1> 		mul cl				; multiply by byute count - we now have numebr of bits to shift right
    43 00000032 88C1                <1> 		mov cl,al
    44 00000034 66D3CA              <1> 		ror edx,cl
    45 00000037 6659                <1> 		pop ecx				; restore cl
    46 00000039 D0E1                <1> 		shl cl,1			; multiply by 2 for nibbles
    47                              <1> 		; todo: could put check in for a value greater than 4
    48                              <1> hexLoop:
    49 0000003B 80F900              <1> 		cmp cl,0			; if bx = 0 then exit
    50 0000003E 7416                <1>         jz hexFin 
    51 00000040 66C1C204            <1>         rol edx,4        	; Rotate the word to get first byte ready
    52 00000044 49                  <1>         dec cx
    53                              <1>         ; Swap 
    54 00000045 88D0                <1>         mov al,dl       	; copy byte into AL
    55 00000047 240F                <1> 	and al,0x0f		; clear high nibble
    56                              <1>         
    57                              <1>         ; Handle al first
    58 00000049 3C0A                <1>         cmp al,0x0a
    59 0000004B 7202                <1> 	jb nibLess
    60 0000004D 0407                <1> 	add al,0x07		; add offset for Hex letters
    61                              <1> nibLess: 			 
    62 0000004F 0430                <1> 	add al,0x30 
    63 00000051 E8C7FF              <1>         call printChar
    64 00000054 EBE5                <1>         jmp hexLoop
    65                              <1> hexFin:
    66 00000056 C3                  <1>         ret
    67                              <1> 
    68                              <1> 
    69 00000057 0A0D00              <1> NEW_LINE:	db  0xa, 0xd,0
    24                                  %include "gdt.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; GDT - Global Discriptor table
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> 
     5                              <1> gdt_start: 
     6                              <1> 
     7                              <1> gdt_null:       ;the madatory null descriptor
     8 0000005A 00000000            <1>     dd 0x0
     9 0000005E 00000000            <1>     dd 0x0
    10                              <1> 
    11                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    12                              <1> ; CODE SEGMENT descriptor
    13                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    14                              <1> 
    15                              <1> gdt_code:      
    16                              <1> 
    17 00000062 FFFF                <1>     dw 0xffff       ; Limite (bits 0-15)
    18 00000064 0000                <1>     dw 0x0          ; Base (bits 0-15)
    19 00000066 00                  <1>     db 0x0          ; Base (bits 16-23)
    20 00000067 9A                  <1>     db 10011010b    ; 1st flags, type flags
    21 00000068 CF                  <1>     db 11001111b    ; 2nd flags, limit (bits 16-19)
    22 00000069 00                  <1>     db 0x0          ; Base (bits 24-31)
    23                              <1> 
    24                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                              <1> ; DATA SEGMENT descriptor
    26                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    27                              <1> 
    28                              <1> gdt_data:       ; The data segment desciptor
    29                              <1> 
    30 0000006A FFFF                <1>     dw 0xffff       ; Limit (bits 0-15)
    31 0000006C 0000                <1>     dw 0x0          ; Base (bits 0-15)
    32 0000006E 00                  <1>     db 0x0          ; Base (bits 16-23)
    33 0000006F 92                  <1>     db 10010010b    ; 1st flags, type flags
    34 00000070 CF                  <1>     db 11001111b    ; 2nd flags. Limit (bits 16-19)
    35 00000071 00                  <1>     db 0x0          ; Base (bits 24-31)
    36                              <1> 
    37                              <1> gdt_end: 
    38                              <1> 
    39                              <1> 
    40                              <1> ; GDT Descriptor
    41                              <1> gdt_descriptor: 
    42 00000072 1700                <1>     dw gdt_end - gdt_start -1
    43 00000074 [5A000000]          <1>     dd gdt_start
    44                              <1> 
    45                              <1> 
    46                              <1> CODE_SEG    equ gdt_code - gdt_start
    47                              <1> DATA_SEG    equ gdt_data - gdt_start
    48                              <1> 
    49                              <1> 
    25                                  %include "print32.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; Print routines for 32 bit protected mode
     3                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                              <1> 
     5                              <1> [bits 32]
     6                              <1> 
     7                              <1> VIDEO_MEMORY        equ 0xb8000
     8                              <1> VIDEO_MEMORY_SIZE   equ 0xfa0
     9                              <1> WHITE_ON_BLACK      equ 0x0f
    10                              <1> WHITE_ON_BLUE       equ 0x1f
    11                              <1> BLUE_ON_GRAY        equ 0x0A
    12                              <1> 
    13                              <1> 
    14                              <1> 
    15                              <1> COLOR_BLACK         equ 0x000000
    16                              <1> COLOR_BLUE          equ 0x0000AA
    17                              <1> COLOR_GREEN         equ 0x00AA00
    18                              <1> COLOR_CYAN          equ 0x00AAAA
    19                              <1> COLOR_RED           equ 0xAA0000
    20                              <1> COLOR_PURPLE        equ 0xAA00AA
    21                              <1> COLOR_BROWN         equ 0xAA5500
    22                              <1> COLOR_GRAY          equ 0xAAAAAA
    23                              <1> COLOR_LT_BLUE       equ 0x5555FF
    24                              <1> 
    25                              <1> cls:
    26 00000078 60                  <1>     pusha  
    27 00000079 BB9F0F0000          <1>     mov ebx, VIDEO_MEMORY_SIZE-1
    28 0000007E BA00800B00          <1>     mov edx, VIDEO_MEMORY
    29 00000083 B020                <1>     mov al,0x20                 ; Space character
    30 00000085 B41F                <1>     mov ah,WHITE_ON_BLUE
    31                              <1> clsloop:
    32 00000087 668902              <1>     mov [edx],ax
    33 0000008A 4B                  <1>     dec ebx
    34 0000008B 83C202              <1>     add edx, 2
    35 0000008E 83FB00              <1>     cmp ebx,0
    36 00000091 75F4                <1>     jne clsloop
    37 00000093 61                  <1>     popa
    38 00000094 C3                  <1>     ret
    39                              <1>     
    40                              <1> print_string_pm:
    41 00000095 60                  <1> 	pusha
    42 00000096 BA00800B00          <1> 	mov edx, VIDEO_MEMORY
    43                              <1> 
    44                              <1> print_string_pm_loop:
    45 0000009B 8A03                <1> 	mov al, [ebx]
    46 0000009D B41F                <1> 	mov ah, WHITE_ON_BLUE
    47                              <1> 
    48 0000009F 3C00                <1> 	cmp al, 0
    49 000000A1 740B                <1> 	je print_string_pm_done
    50                              <1> 
    51 000000A3 668902              <1> 	mov [edx], ax
    52                              <1> 
    53 000000A6 83C301              <1> 	add ebx, 1
    54 000000A9 83C202              <1> 	add edx, 2
    55                              <1> 
    56 000000AC EBED                <1> 	jmp print_string_pm_loop
    57                              <1> 
    58                              <1> print_string_pm_done:
    59 000000AE 61                  <1> 	popa
    60 000000AF C3                  <1> 	ret
    26                                  %include "switchPM.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; Routine to switch from 16 Real Mode into 
     3                              <1> ; 32 bit protected mode
     4                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                              <1> 
     6                              <1> [bits 16]
     7                              <1> switch_to_pm:
     8 000000B0 FA                  <1> 	cli                         ; Clear interrupt flag
     9 000000B1 0F0116[7200]        <1> 	lgdt [gdt_descriptor]       ; Load the GDT descriptor
    10                              <1> 	
    11 000000B6 0F20C0              <1> 	mov eax,cr0                 ; Set the proteced mode flag
    12 000000B9 6683C801            <1> 	or eax, 0x1
    13 000000BD 0F22C0              <1> 	mov cr0,eax
    14                              <1> 
    15 000000C0 EA[C500]0800        <1> 	jmp CODE_SEG:init_pm        ; Jump to the new CODE segment as per the GDT
    16                              <1> 
    17                              <1> 
    18                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    19                              <1> ; 32 MODE Code
    20                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    21                              <1> 
    22                              <1> [bits 32]
    23                              <1> 
    24                              <1> ; Initialise registers and the stack once in PM
    25                              <1> init_pm:
    26 000000C5 66B81000            <1> 	mov ax, DATA_SEG	; Move old Segments to DATA_SEG defined in GDT
    27 000000C9 8ED8                <1> 	mov ds, ax
    28 000000CB 8ED0                <1> 	mov ss, ax
    29 000000CD 8EC0                <1> 	mov es, ax
    30 000000CF 8EE0                <1> 	mov fs, ax
    31 000000D1 8EE8                <1> 	mov gs, ax
    32                              <1> 
    33 000000D3 BD00000900          <1> 	mov ebp, 0x90000	; Update stack point to top of free space
    34 000000D8 89EC                <1> 	mov esp, ebp		
    35                              <1> 
    36 000000DA E818000000          <1> 	call BEGIN_PM       ; Call the begining of main code 
    37                              <1> 	
    27                                  
    28 000000DF 5374617274696E6720-     MSG_REAL_MODE db "Starting in 16-Bit Mode",0
    28 000000E8 696E2031362D426974-
    28 000000F1 204D6F646500       
    29                                  
    30                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                                  ; Protected Mode code 
    32                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    33                                  
    34                                  BEGIN_PM:
    35                                  	; TODO: clear screen (direct write to memory
    36 000000F7 E87CFFFFFF                  call cls
    37 000000FC BB[08010000]            	mov ebx, MSG_PROT_MODE		; Print Message
    38 00000101 E88FFFFFFF              	call print_string_pm
    39                                  
    40 00000106 EBFE                    	jmp $
    41                                  
    42 00000108 537563636573732120-     MSG_PROT_MODE db "Success! We are in 32 bit protected mode",0
    42 00000111 57652061726520696E-
    42 0000011A 203332206269742070-
    42 00000123 726F74656374656420-
    42 0000012C 6D6F646500         
    43                                  
    44 00000131 00<rep CDh>             	times 510-($-$$) db 0
    45 000001FE 55AA                    	dw 0xaa55
