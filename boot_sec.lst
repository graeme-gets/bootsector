     1                                  [org 0x7c00]
     2                                  
     3 00000000 BD0090                  	mov bp, 0x9000
     4 00000003 89EC                    	mov sp, bp
     5                                  
     6 00000005 BE[C200]                	mov si, MSG_REAL_MODE
     7 00000008 E80500                  	call printString
     8                                  
     9 0000000B E88500                  	call switch_to_pm
    10                                  
    11 0000000E EBFE                    	jmp $
    12                                  
    13                                  %include "print.asm"
     1                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                              <1> ; Prints null terminated string
     3                              <1> ; Put first letter into SI
     4                              <1> ; Set BX to number of bytes to use
     5                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6                              <1> printString:
     7 00000010 AC                  <1> 	lodsb				; Load the byte at address in SI to AL and Inc SI
     8 00000011 3C00                <1> 	cmp al,0			; check for end of line
     9 00000013 7405                <1> 	je printStringEnd
    10 00000015 E80300              <1> 	call printChar
    11 00000018 EBF6                <1> 	jmp printString
    12                              <1> printStringEnd:
    13 0000001A C3                  <1> 	ret
    14                              <1> 
    15                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    16                              <1> ; Prints a single character to the BIOS Teletype function
    17                              <1> ; Put char in AL
    18                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    19                              <1> printChar:
    20                              <1> 	; Call BIOS Routing to print
    21 0000001B 50                  <1> 	push ax
    22 0000001C 53                  <1> 	push bx
    23 0000001D B40E                <1> 	mov ah, 0x0e		; BIOS Teletype function
    24 0000001F B700                <1> 	mov bh,0			; Page 0
    25 00000021 B347                <1> 	mov bl, 0x47		; Text Attribute (light grey on black)
    26 00000023 CD10                <1> 	int 0x10			; call BIOS intterupt 0x10
    27 00000025 5B                  <1> 	pop bx
    28 00000026 58                  <1> 	pop ax
    29 00000027 C3                  <1> 	ret
    30                              <1> 
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ; Prints a byte or word in hex format
    33                              <1> ; Assumes value is in DX and can be 32 bit value
    34                              <1> ; Set BX to number of bytes to use
    35                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    36                              <1> printHex:
    37 00000028 6651                <1> 		push ecx				; save cl
    38 0000002A B004                <1> 		mov al,4			; load number of bytes for full 32 bit number
    39 0000002C 28C8                <1> 		sub al,cl			; get number of byte to shift out for alignment	
    40 0000002E B108                <1> 		mov cl,8			; set bit multiplier
    41 00000030 F6E1                <1> 		mul cl				; multiply by byute count - we now have numebr of bits to shift right
    42 00000032 88C1                <1> 		mov cl,al
    43 00000034 66D3CA              <1> 		ror edx,cl
    44 00000037 6659                <1> 		pop ecx				; restore cl
    45 00000039 D0E1                <1> 		shl cl,1			; multiply by 2 for nibbles
    46                              <1> 		; todo: could put check in for a value greater than 4
    47                              <1> hexLoop:
    48 0000003B 80F900              <1> 		cmp cl,0			; if bx = 0 then exit
    49 0000003E 7416                <1>         jz hexFin 
    50 00000040 66C1C204            <1>         rol edx,4        ; Rotate the word to get first byte ready
    51 00000044 49                  <1>         dec cx
    52                              <1>         ; Swap 
    53 00000045 88D0                <1>         mov al,dl       ; copy byte into AL
    54 00000047 240F                <1> 		and al,0x0f		; clear high nibble
    55                              <1>         
    56                              <1>         ; Handle al first
    57 00000049 3C0A                <1>         cmp al,0x0a
    58 0000004B 7202                <1> 		jb nibLess
    59 0000004D 0407                <1> 		add al,0x07		; add offset for Hex letters
    60                              <1> nibLess: 			 
    61 0000004F 0430                <1> 		add al,0x30 
    62 00000051 E8C7FF              <1>         call printChar
    63 00000054 EBE5                <1>         jmp hexLoop
    64                              <1> hexFin:
    65 00000056 C3                  <1>         ret
    66                              <1> 
    67                              <1> 
    68 00000057 0A0D00              <1> NEW_LINE:	db  0xa, 0xd,0
    14                                  %include "gdt.asm"
     1                              <1> ; GDT
     2                              <1> 
     3                              <1> gdt_start: 
     4                              <1> 
     5                              <1> gdt_null:       ;the madatory null descriptor
     6 0000005A 00000000            <1>     dd 0x0
     7 0000005E 00000000            <1>     dd 0x0
     8                              <1> 
     9                              <1> gdt_code :       ; The code segment descriptor
    10                              <1> 
    11 00000062 FFFF                <1>     dw 0xffff       ; Limite (bits 0-15)
    12 00000064 0000                <1>     dw 0x0          ; Base (bits 0-15)
    13 00000066 00                  <1>     db 0x0          ; Base (bits 16-23)
    14 00000067 9A                  <1>     db 10011010b    ; 1st flags, type flags
    15 00000068 CF                  <1>     db 11001111b    ; 2nd flags, limit (bits 16-19)
    16 00000069 00                  <1>     db 0x0          ; Base (bits 24-31)
    17                              <1> 
    18                              <1> 
    19                              <1> gdt_data:       ; The data segment desciptor
    20                              <1> 
    21 0000006A FFFF                <1>     dw 0xffff       ; Limit (bits 0-15)
    22 0000006C 0000                <1>     dw 0x0          ; Base (bits 0-15)
    23 0000006E 00                  <1>     db 0x0          ; Base (bits 16-23)
    24 0000006F 92                  <1>     db 10010010b    ; 1st flags, type flags
    25 00000070 CF                  <1>     db 11001111b    ; 2nd flags. Limit (bits 16-19)
    26 00000071 00                  <1>     db 0x0          ; Base (bits 24-31)
    27                              <1> 
    28                              <1> gdt_end: 
    29                              <1> 
    30                              <1> 
    31                              <1> ; GDT Descriptor
    32                              <1> gdt_descriptor: 
    33 00000072 1700                <1>     dw gdt_end - gdt_start -1
    34 00000074 [5A000000]          <1>     dd gdt_start
    35                              <1> 
    36                              <1> 
    37                              <1> CODE_SEG    equ gdt_code - gdt_start
    38                              <1> DATA_SEG    equ gdt_data - gdt_start
    39                              <1> 
    40                              <1> 
    15                                  %include "print_string_pm.asm"
     1                              <1> [bits 32]
     2                              <1> 
     3                              <1> VIDEO_MEMORY equ 0xb8000
     4                              <1> WHITE_ON_BLACK equ 0x0f
     5                              <1> 
     6                              <1> print_string_pm:
     7 00000078 60                  <1> 	pusha
     8 00000079 BA00800B00          <1> 	mov edx, VIDEO_MEMORY
     9                              <1> 
    10                              <1> print_string_pm_loop:
    11 0000007E 8A03                <1> 	mov al, [ebx]
    12 00000080 B40F                <1> 	mov ah, WHITE_ON_BLACK
    13                              <1> 
    14 00000082 3C00                <1> 	cmp al, 0
    15 00000084 740B                <1> 	je print_string_pm_done
    16                              <1> 
    17 00000086 668902              <1> 	mov [edx], ax
    18                              <1> 
    19 00000089 83C301              <1> 	add ebx, 1
    20 0000008C 83C202              <1> 	add edx, 2
    21                              <1> 
    22 0000008F EBED                <1> 	jmp print_string_pm_loop
    23                              <1> 
    24                              <1> print_string_pm_done:
    25 00000091 61                  <1> 	popa
    26 00000092 C3                  <1> 	ret
    16                                  %include "switchPM.asm"
     1                              <1> [bits 16]
     2                              <1> 
     3                              <1> ; Switch tp protected mode
     4                              <1> 
     5                              <1> switch_to_pm:
     6 00000093 FA                  <1> 	cli
     7                              <1> 	
     8 00000094 0F0116[7200]        <1> 	lgdt [gdt_descriptor]
     9                              <1> 	
    10 00000099 0F20C0              <1> 	mov eax,cr0
    11 0000009C 6683C801            <1> 	or eax, 0x1
    12 000000A0 0F22C0              <1> 	mov cr0,eax
    13                              <1> 
    14 000000A3 EA[A800]0800        <1> 	jmp CODE_SEG:init_pm
    15                              <1> 
    16                              <1> 
    17                              <1> [bits 32]
    18                              <1> ; Initialise registers and the stack once in PM
    19                              <1> init_pm:
    20 000000A8 66B81000            <1> 	mov ax, DATA_SEG	; Move old Segments to DATA_SEG defined in GDT
    21 000000AC 8ED8                <1> 	mov ds, ax
    22 000000AE 8ED0                <1> 	mov ss, ax
    23 000000B0 8EC0                <1> 	mov es, ax
    24 000000B2 8EE0                <1> 	mov fs, ax
    25 000000B4 8EE8                <1> 	mov gs, ax
    26                              <1> 
    27 000000B6 BD00000900          <1> 	mov ebp, 0x90000	; Update stack point to top of free space
    28 000000BB 89EC                <1> 	mov esp, ebp		
    29                              <1> 
    30 000000BD E818000000          <1> 	call BEGIN_PM
    31                              <1> 	
    17                                  
    18 000000C2 5374617274696E6720-     MSG_REAL_MODE db "Starting in 16-Bit Mode",0
    18 000000CB 696E2031362D426974-
    18 000000D4 204D6F646500       
    19                                  
    20                                  BEGIN_PM:
    21 000000DA BB[E6000000]            	mov ebx, MSG_PROT_MODE
    22 000000DF E894FFFFFF              	call print_string_pm
    23                                  
    24 000000E4 EBFE                    	jmp $
    25                                  
    26                                  ;MSG_REAL_MODE db "Starting in 16-Bit Mode",0
    27 000000E6 537563636573732120-     MSG_PROT_MODE db "Success! We are in 32 bit protected mode",0
    27 000000EF 57652061726520696E-
    27 000000F8 203332206269742070-
    27 00000101 726F74656374656420-
    27 0000010A 6D6F646500         
    28                                  
    29 0000010F 00<rep EFh>             	times 510-($-$$) db 0
    30 000001FE 55AA                    	dw 0xaa55
